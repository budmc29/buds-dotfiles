/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const stream_1 = require("stream");
const util_1 = require("util");
const messages_1 = require("../messages");
const cancellation_1 = require("../cancellation");
const hostConnection = require("../main");
let TestDuplex = function () {
    function TestDuplex(name = 'ds1', dbg = false) {
        stream_1.Duplex.call(this);
        this.name = name;
        this.dbg = dbg;
    }
    util_1.inherits(TestDuplex, stream_1.Duplex);
    TestDuplex.prototype._write = function (chunk, _encoding, done) {
        if (this.dbg)
            console.log(this.name + ': write: ' + chunk.toString());
        setImmediate(() => {
            this.emit('data', chunk);
        });
        done();
    };
    TestDuplex.prototype._read = function (_size) {
    };
    return TestDuplex;
}();
let Logger = {
    error: (_message) => { },
    warn: (_message) => { },
    info: (_message) => { },
    log: (_message) => { }
};
describe('Connection', () => {
    it('Test Duplex Stream', (done) => {
        let stream = new TestDuplex('ds1');
        stream.on('data', (chunk) => {
            assert.strictEqual('Hello World', chunk.toString());
            done();
        });
        stream.write('Hello World');
    });
    it('Test Duplex Stream Connection', (done) => {
        let type = new messages_1.RequestType('test/handleSingleRequest');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let connection = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        connection.listen();
        let counter = 0;
        let content = "";
        duplexStream2.on('data', (chunk) => {
            content += chunk.toString();
            if (++counter === 2) {
                assert.strictEqual(content.indexOf("Content-Length: 75"), 0);
                done();
            }
        });
        connection.sendRequest(type, 'foo');
    });
    it('Handle Single Request', (done) => {
        let type = new messages_1.RequestType('test/handleSingleRequest');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (p1, _token) => {
            assert.strictEqual(p1, 'foo');
            return p1;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendRequest(type, 'foo').then((result) => {
            assert.strictEqual(result, 'foo');
            done();
        });
    });
    it('Handle Multiple Requests', (done) => {
        let type = new messages_1.RequestType('test/handleSingleRequest');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (p1, _token) => {
            return p1;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        let promises = [];
        promises.push(client.sendRequest(type, 'foo'));
        promises.push(client.sendRequest(type, 'bar'));
        Promise.all(promises).then((values) => {
            assert.strictEqual(values.length, 2);
            assert.strictEqual(values[0], 'foo');
            assert.strictEqual(values[1], 'bar');
            done();
        });
    });
    it('Unhandled Request', (done) => {
        let type = new messages_1.RequestType('test/handleSingleRequest');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendRequest(type, 'foo').then((_result) => {
        }, (error) => {
            assert.strictEqual(error.code, messages_1.ErrorCodes.MethodNotFound);
            done();
        });
    });
    it('Receives undefined param as null', (done) => {
        let type = new messages_1.RequestType('test/handleSingleRequest');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (param) => {
            assert.strictEqual(param, null);
            return '';
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendRequest(type, undefined).then((_result) => {
            done();
        });
    });
    it('Receives null as null', (done) => {
        let type = new messages_1.RequestType('test/handleSingleRequest');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (param) => {
            assert.strictEqual(param, null);
            return null;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendRequest(type, null).then(result => {
            assert.deepEqual(result, null);
            done();
        });
    });
    it('Receives 0 as 0', (done) => {
        let type = new messages_1.RequestType('test/handleSingleRequest');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (param) => {
            assert.strictEqual(param, 0);
            return 0;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendRequest(type, 0).then(result => {
            assert.deepEqual(result, 0);
            done();
        });
    });
    let testNotification = new messages_1.NotificationType("testNotification");
    it('Send and Receive Notification', (done) => {
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onNotification(testNotification, (param) => {
            assert.strictEqual(param.value, true);
            done();
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendNotification(testNotification, { value: true });
    });
    it('Unhandled notification event', (done) => {
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onUnhandledNotification((message) => {
            assert.strictEqual(message.method, testNotification.method);
            done();
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendNotification(testNotification, { value: true });
    });
    it('Dispose connection', (done) => {
        let type = new messages_1.RequestType('test/handleSingleRequest');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (_param) => {
            client.dispose();
            return '';
        });
        server.listen();
        client.listen();
        client.sendRequest(type, '').then(_result => {
            assert(false);
        }, () => {
            done();
        });
    });
    it('Disposed connection throws', (done) => {
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.dispose();
        try {
            client.sendNotification(testNotification);
            assert(false);
        }
        catch (error) {
            done();
        }
    });
    it('Two listen throw', (done) => {
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        try {
            client.listen();
            assert(false);
        }
        catch (error) {
            done();
        }
    });
    it('Notify on connection dispose', (done) => {
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.onDispose(() => {
            done();
        });
        client.dispose();
    });
    it('N params in notifications', (done) => {
        let type = new messages_1.NotificationType2('test');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onNotification(type, (p1, p2) => {
            assert.strictEqual(p1, 10);
            assert.strictEqual(p2, 'vscode');
            done();
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendNotification(type, 10, 'vscode');
    });
    it('N params in request / response', (done) => {
        let type = new messages_1.RequestType3('add');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (p1, p2, p3) => {
            assert.strictEqual(p1, 10);
            assert.strictEqual(p2, 20);
            assert.strictEqual(p3, 30);
            return p1 + p2 + p3;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendRequest(type, 10, 20, 30).then(result => {
            assert.strictEqual(result, 60);
            done();
        }, () => {
            assert(false);
            done();
        });
    });
    it('N params in request / response with token', (done) => {
        let type = new messages_1.RequestType3('add');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (p1, p2, p3, _token) => {
            assert.strictEqual(p1, 10);
            assert.strictEqual(p2, 20);
            assert.strictEqual(p3, 30);
            return p1 + p2 + p3;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        let token = new cancellation_1.CancellationTokenSource().token;
        client.listen();
        client.sendRequest(type, 10, 20, 30, token).then(result => {
            assert.strictEqual(result, 60);
            done();
        }, () => {
            assert(false);
            done();
        });
    });
    it('One Param as array in request', (done) => {
        let type = new messages_1.RequestType('add');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (p1) => {
            assert(Array.isArray(p1));
            assert.strictEqual(p1[0], 10);
            assert.strictEqual(p1[1], 20);
            assert.strictEqual(p1[2], 30);
            return 60;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        let token = new cancellation_1.CancellationTokenSource().token;
        client.listen();
        client.sendRequest(type, [10, 20, 30], token).then(result => {
            assert.strictEqual(result, 60);
            done();
        }, () => {
            assert(false);
            done();
        });
    });
    it('One Param as array in notification', (done) => {
        let type = new messages_1.NotificationType('add');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onNotification(type, (p1) => {
            assert(Array.isArray(p1));
            assert.strictEqual(p1[0], 10);
            assert.strictEqual(p1[1], 20);
            assert.strictEqual(p1[2], 30);
            done();
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendNotification(type, [10, 20, 30]);
    });
    it('Untyped request / response', (done) => {
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest('test', (p1, p2, p3, _token) => {
            assert.strictEqual(p1, 10);
            assert.strictEqual(p2, 20);
            assert.strictEqual(p3, 30);
            return p1 + p2 + p3;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        let token = new cancellation_1.CancellationTokenSource().token;
        client.listen();
        client.sendRequest('test', 10, 20, 30, token).then((result) => {
            assert.strictEqual(result, 60);
            done();
        }, () => {
            assert(false);
            done();
        });
    });
    it('Cancellation token is undefined', (done) => {
        let type = new messages_1.RequestType3('add');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (p1, p2, p3, _token) => {
            assert.strictEqual(p1, 10);
            assert.strictEqual(p2, 20);
            assert.strictEqual(p3, 30);
            return p1 + p2 + p3;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendRequest(type, 10, 20, 30, undefined).then(result => {
            assert.strictEqual(result, 60);
            done();
        }, () => {
            assert(false);
            done();
        });
    });
    it('Missing params in request', (done) => {
        let type = new messages_1.RequestType3('add');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onRequest(type, (p1, p2, p3, _token) => {
            assert.strictEqual(p1, 10);
            assert.strictEqual(p2, 20);
            assert.strictEqual(p3, null);
            return p1 + p2;
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendRequest(type, 10, 20).then((result) => {
            assert.strictEqual(result, 30);
            done();
        }, () => {
            assert(false);
            done();
        });
    });
    it('Missing params in notifications', (done) => {
        let type = new messages_1.NotificationType2('test');
        let duplexStream1 = new TestDuplex('ds1');
        let duplexStream2 = new TestDuplex('ds2');
        let server = hostConnection.createMessageConnection(duplexStream2, duplexStream1, Logger);
        server.onNotification(type, (p1, p2) => {
            assert.strictEqual(p1, 10);
            assert.strictEqual(p2, null);
            done();
        });
        server.listen();
        let client = hostConnection.createMessageConnection(duplexStream1, duplexStream2, Logger);
        client.listen();
        client.sendNotification(type, 10);
    });
});
